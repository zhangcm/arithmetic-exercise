
## 零、套路
1. 穷举
如何聪明的穷举
2. 递归
把大的问题细化到一个点，先研究在这个小的点上如何解决问题，然后再通过递归/迭代的方式扩展到整个问题。

## 一、二叉树

### 一般思路

### 常用框架

## 二、BFS

## 三、链表

### 3.1 一般思路

### 3.2 常用框架

#### 3.2.1 链表反转
```java
private static ListNode reverse(ListNode head) {
    ListNode cur = head;
    ListNode pre = null;
    while (cur != null) {
        ListNode next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return head;
}
```

## 四、数组

## 五、回溯



## 六、动态规划 

### 6.1 大纲

首先，动态规划问题的一般形式就是求最值。比如最长子序列，最小编辑距离，最长公共子串等等等。这就是规律，
因为动态规划本身就是运筹学里的一种求最值的算法。

求解动态规划的核心问题是穷举。

三要素：
1. 重叠子问题，通过[DP Table]优化
2. 最优子结构
3. 状态转移方程

思维框架：
明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。

```java
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

动态规划的难点在于寻找正确的状态转移方程，找状态转移方程的一个通用技巧是数学归纳思想。

我们先假设这个结论在 k<n 时成立，然后根据这个假设，想办法推导证明出 k=n 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。

如何找到动态规划的状态转移关系：

1、明确 dp 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

2、根据 dp 数组的定义，运用数学归纳法的思想，假设 dp[0...i-1] 都已知，想办法求出 dp[i]，一旦这一步完成，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。

##### dp数组的定义


### 6.2 常用思路
1. 解决两个字符串的动态规划问题，一般都是用两个指针 i,j 分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模。
2. 先找出涉及的维度，如果有两个维度，可以考虑固定其中一个，将问题进行转化，比如俄罗斯套娃问题。

### 子序列

两种思路

1. 第一种思路模板是一个一维的dp数组
```java
int n = array.length
int[] dp = new int[n];
for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        dp[i] = 最值(dp[i], dp[j] + ...)
    }
}
```
在子数组array[0..i]中，以arrya[i]结尾的目标子序列（最长递增子序列）的长度是dp[i]。

这样符合归纳法，可以找到状态转移的关系。

2. 第二种思路模板是一个二维的dp数组
```java
int n = arr.length;
int[][] dp = new dp[n][n];

for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        if (arr[i] == arr[j]) {
            dp[i][j] = dp[i][j] + ...
        } else {
            dp[i][j] = 最值(...)
        }
    }
}
```
2.1 涉及两个字符串/数组时，dp数组的含义如下：
在子数组arr1[0..i]和子数组arr2[0..j]中，我们要求的子序列(最长公共子序列)长度为dp[i][j]
2.2 只涉及一个字符串/数组时，dp数组的含义如下：
在子数组array[i..j]中，我们要求的子序列（最长回文子序列）的长度为dp[i][j]

什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。
比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。

什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。


#### 分类

##### 区间问题
区间问题肯定按照区间的起点或者终点进行排序。
因为排序之后更容易找到相邻区间之间的联系，如果是求最值的问题，可以使用贪心算法进行求解。

##### 子序列问题


##### 正则表达式问题
看两个字符是否匹配，一切逻辑围绕匹配/不匹配两种情况展开即可。

##### 博弈问题
博弈问题的难点在于，两个人要轮流进行选择，而且都贼精明，应该如何编程表示这个过程呢？

核心思路是在二维 dp 的基础上使用元组分别存储两个人的博弈结果。
